# 简单介绍

  `tcmalloc`是由`google`公司早期开发的**内存分配器**, 可以轻松与大部分项目配合使用. 

# 快速使用

  我们可以通过以下方式来使用

## 1. 动态链接

  通过动态链接`tcmalloc`/`tcmalloc_minimal`, 这种方式适用于大部分系统(包括:`Windows`)

## 2. 优先加载

  通过设置`LD_PRELOAD=/path/libtcmalloc.so`, 这种方式适用于大部分[Unix-Like](https://en.wikipedia.org/wiki/Unix-like)系统.

# 有哪些优势与差异?

  您可以在[性能评估](https://tcmalloc.cn/performance)文章里获得信息, 也可以通过从网上分享的文章来了解更多.

  这里简单描述一下优势：

  * 更低的分配延迟：`tcmalloc`的malloc/free操作耗时约为50纳秒，而`ptmalloc2`需300纳秒，效率提升显著，尤其适合高频频繁小对象分配的应用（如C++容器操作）可显著降低延迟。
  
  * 线程局部缓存（Thread-Caching）：通过为每个线程维护独立的内存缓存池，减少多线程环境下的锁竞争，提升并发性能。对于小对象（≤32KB）分配，几乎无锁开销；大对象则采用高效自旋锁。
  
  * 分层设计：采用Front-end（线程缓存）、Middle-end（中央堆）、Back-end（页堆）三级架构，动态平衡线程间内存分配需求，减少碎片并提升复用率。

  * 按需回收机制：空闲时自动回收线程缓存的内存供其他线程使用，避免ptmalloc2因线程间内存池不可迁移导致的空间浪费。
  
  * 细粒度锁策略：针对多核CPU优化，通过减少全局锁依赖（如Per-CPU模式）提升扩展性，性能随核心数增长更线性。
  
  * 内置堆分析工具：支持堆栈跟踪记录，便于检测内存泄漏和瓶颈，而`glibc`需依赖外部工具（如`Valgrind`）。


# 缓解内存碎片

  可以! 没有使用`tcmalloc`的程序在动态地分配和释放内存时, 会导致内存中出现不连续的小块空闲内存. 这些小块空闲内存如果不能被整合有效地利用就会形成**内存碎片**.

  而`tcmalloc`通过分层设计合理的利用内存池和分配策略能减少频繁的向系统进行小内存的分配, 在缓解内存碎片产生的同时减少了大量系统调用, 因此可以认为提高了整体的内存申请效率.

# 实测的性能差?

  1. 可以检查您是否使用`cmake`构建于`Release`模式.

  2. 当前系统/内核是否提供完整的特性, 有限支持的平台可能性能不佳.
